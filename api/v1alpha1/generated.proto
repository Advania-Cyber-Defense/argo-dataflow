/*


Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = 'proto2';

package github.com.argoproj_labs.argo_dataflow.api.v1alpha1;

import "k8s.io/apimachinery/pkg/api/resource/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/util/intstr/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "v1alpha1";

message AWSElasticBlockStoreVolumeSource {
  // Unique ID of the persistent disk resource in AWS (Amazon EBS volume).
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
  optional string volumeID = 1;

  // Filesystem type of the volume that you want to mount.
  // Tip: Ensure that the filesystem type is supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  // +optional
  optional string fsType = 2;

  // The partition in the volume that you want to mount.
  // If omitted, the default is to mount by volume name.
  // Examples: For volume /dev/sda1, you specify the partition as "1".
  // Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
  // +optional
  optional int32 partition = 3;

  // Specify "true" to force and set the ReadOnly property in VolumeMounts to "true".
  // If omitted, the default is "false".
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
  // +optional
  optional bool readOnly = 4;
}

message AzureDiskVolumeSource {
  // The Name of the data disk in the blob storage
  optional string diskName = 1;

  // The URI the data disk in the blob storage
  optional string diskURI = 2;

  // Host Caching mode: None, Read Only, Read Write.
  // +optional
  optional string cachingMode = 3;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // +optional
  optional string fsType = 4;

  // Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // +optional
  optional bool readOnly = 5;

  // Expected values Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
  optional string kind = 6;
}

message AzureFileVolumeSource {
  // the name of secret that contains Azure Storage Account Name and Key
  optional string secretName = 1;

  // Share Name
  optional string shareName = 2;

  // Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // +optional
  optional bool readOnly = 3;
}

message CSIVolumeSource {
  // Driver is the name of the CSI driver that handles this volume.
  // Consult with your admin for the correct name as registered in the cluster.
  optional string driver = 1;

  // Specifies a read-only configuration for the volume.
  // Defaults to false (read/write).
  // +optional
  optional bool readOnly = 2;

  // Filesystem type to mount. Ex. "ext4", "xfs", "ntfs".
  // If not provided, the empty value is passed to the associated CSI driver
  // which will determine the default filesystem to apply.
  // +optional
  optional string fsType = 3;

  // VolumeAttributes stores driver-specific properties that are passed to the CSI
  // driver. Consult your driver's documentation for supported values.
  // +optional
  map<string, string> volumeAttributes = 4;

  // NodePublishSecretRef is a reference to the secret object containing
  // sensitive information to pass to the CSI driver to complete the CSI
  // NodePublishVolume and NodeUnpublishVolume calls.
  // This field is optional, and  may be empty if no secret is required. If the
  // secret object contains more than one secret, all secret references are passed.
  // +optional
  optional LocalObjectReference nodePublishSecretRef = 5;
}

message Capabilities {
  // Added capabilities
  // +optional
  repeated string add = 1;

  // Removed capabilities
  // +optional
  repeated string drop = 2;
}

message CephFSVolumeSource {
  // Required: Monitors is a collection of Ceph monitors
  // More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  repeated string monitors = 1;

  // Optional: Used as the mounted root, rather than the full Ceph tree, default is /
  // +optional
  optional string path = 2;

  // Optional: User is the rados user name, default is admin
  // More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  // +optional
  optional string user = 3;

  // Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
  // More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  // +optional
  optional string secretFile = 4;

  // Optional: SecretRef is reference to the authentication secret for User, default is empty.
  // More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  // +optional
  optional LocalObjectReference secretRef = 5;

  // Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  // +optional
  optional bool readOnly = 6;
}

message CinderVolumeSource {
  // volume id used to identify the volume in cinder.
  // More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  optional string volumeID = 1;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  // +optional
  optional string fsType = 2;

  // Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  // +optional
  optional bool readOnly = 3;

  // Optional: points to a secret object containing parameters used to connect
  // to OpenStack.
  // +optional
  optional LocalObjectReference secretRef = 4;
}

message ConfigMapEnvSource {
  // The ConfigMap to select from.
  optional LocalObjectReference localObjectReference = 1;

  // Specify whether the ConfigMap must be defined
  // +optional
  optional bool optional = 2;
}

message ConfigMapKeySelector {
  // The ConfigMap to select from.
  optional LocalObjectReference localObjectReference = 1;

  // The key to select.
  optional string key = 2;

  // Specify whether the ConfigMap or its key must be defined
  // +optional
  optional bool optional = 3;
}

message ConfigMapProjection {
  optional LocalObjectReference localObjectReference = 1;

  // If unspecified, each key-value pair in the Data field of the referenced
  // ConfigMap will be projected into the volume as a file whose name is the
  // key and content is the value. If specified, the listed keys will be
  // projected into the specified paths, and unlisted keys will not be
  // present. If a key is specified which is not present in the ConfigMap,
  // the volume setup will error unless it is marked optional. Paths must be
  // relative and may not contain the '..' path or start with '..'.
  // +optional
  repeated KeyToPath items = 2;

  // Specify whether the ConfigMap or its keys must be defined
  // +optional
  optional bool optional = 4;
}

message ConfigMapVolumeSource {
  optional LocalObjectReference localObjectReference = 1;

  // If unspecified, each key-value pair in the Data field of the referenced
  // ConfigMap will be projected into the volume as a file whose name is the
  // key and content is the value. If specified, the listed keys will be
  // projected into the specified paths, and unlisted keys will not be
  // present. If a key is specified which is not present in the ConfigMap,
  // the volume setup will error unless it is marked optional. Paths must be
  // relative and may not contain the '..' path or start with '..'.
  // +optional
  repeated KeyToPath items = 2;

  // Optional: mode bits used to set permissions on created files by default.
  // Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
  // YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
  // Defaults to 0644.
  // Directories within the path are not affected by this setting.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  // +optional
  optional int32 defaultMode = 3;

  // Specify whether the ConfigMap or its keys must be defined
  // +optional
  optional bool optional = 4;
}

message Container {
  // Name of the container specified as a DNS_LABEL.
  // Each container in a pod must have a unique name (DNS_LABEL).
  // Cannot be updated.
  optional string name = 1;

  // Docker image name.
  // More info: https://kubernetes.io/docs/concepts/containers/images
  // This field is optional to allow higher level config management to default or override
  // container images in workload controllers like Deployments and StatefulSets.
  // +optional
  optional string image = 2;

  // Entrypoint array. Not executed within a shell.
  // The docker image's ENTRYPOINT is used if this is not provided.
  // Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
  // cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax
  // can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
  // regardless of whether the variable exists or not.
  // Cannot be updated.
  // More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  // +optional
  repeated string command = 3;

  // Arguments to the entrypoint.
  // The docker image's CMD is used if this is not provided.
  // Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
  // cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax
  // can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
  // regardless of whether the variable exists or not.
  // Cannot be updated.
  // More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  // +optional
  repeated string args = 4;

  // Container's working directory.
  // If not specified, the container runtime's default will be used, which
  // might be configured in the container image.
  // Cannot be updated.
  // +optional
  optional string workingDir = 5;

  // List of ports to expose from the container. Exposing a port here gives
  // the system additional information about the network connections a
  // container uses, but is primarily informational. Not specifying a port here
  // DOES NOT prevent that port from being exposed. Any port which is
  // listening on the default "0.0.0.0" address inside a container will be
  // accessible from the network.
  // Cannot be updated.
  // +optional
  // +patchMergeKey=containerPort
  // +patchStrategy=merge
  // +listType=map
  // +listMapKey=containerPort
  // +listMapKey=protocol
  repeated ContainerPort ports = 6;

  // List of sources to populate environment variables in the container.
  // The keys defined within a source must be a C_IDENTIFIER. All invalid keys
  // will be reported as an event when the container is starting. When a key exists in multiple
  // sources, the value associated with the last source will take precedence.
  // Values defined by an Env with a duplicate key will take precedence.
  // Cannot be updated.
  // +optional
  repeated EnvFromSource envFrom = 19;

  // List of environment variables to set in the container.
  // Cannot be updated.
  // +optional
  // +patchMergeKey=name
  // +patchStrategy=merge
  repeated EnvVar env = 7;

  // Compute Resources required by this container.
  // Cannot be updated.
  // More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
  // +optional
  optional ResourceRequirements resources = 8;

  // Pod volumes to mount into the container's filesystem.
  // Cannot be updated.
  // +optional
  // +patchMergeKey=mountPath
  // +patchStrategy=merge
  repeated VolumeMount volumeMounts = 9;

  // volumeDevices is the list of block devices to be used by the container.
  // +patchMergeKey=devicePath
  // +patchStrategy=merge
  // +optional
  repeated VolumeDevice volumeDevices = 21;

  // Periodic probe of container liveness.
  // Container will be restarted if the probe fails.
  // Cannot be updated.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  // +optional
  optional Probe livenessProbe = 10;

  // Periodic probe of container service readiness.
  // Container will be removed from service endpoints if the probe fails.
  // Cannot be updated.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  // +optional
  optional Probe readinessProbe = 11;

  // StartupProbe indicates that the Pod has successfully initialized.
  // If specified, no other probes are executed until this completes successfully.
  // If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
  // This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
  // when it might take a long time to load data or warm a cache, than during steady-state operation.
  // This cannot be updated.
  // This is a beta feature enabled by the StartupProbe feature flag.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  // +optional
  optional Probe startupProbe = 22;

  // Actions that the management system should take in response to container lifecycle events.
  // Cannot be updated.
  // +optional
  optional Lifecycle lifecycle = 12;

  // Optional: Path at which the file to which the container's termination message
  // will be written is mounted into the container's filesystem.
  // Message written is intended to be brief final status, such as an assertion failure message.
  // Will be truncated by the node if greater than 4096 bytes. The total message length across
  // all containers will be limited to 12kb.
  // Defaults to /dev/termination-log.
  // Cannot be updated.
  // +optional
  optional string terminationMessagePath = 13;

  // Indicate how the termination message should be populated. File will use the contents of
  // terminationMessagePath to populate the container status message on both success and failure.
  // FallbackToLogsOnError will use the last chunk of container log output if the termination
  // message file is empty and the container exited with an error.
  // The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
  // Defaults to File.
  // Cannot be updated.
  // +optional
  optional string terminationMessagePolicy = 20;

  // Image pull policy.
  // One of Always, Never, IfNotPresent.
  // Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
  // Cannot be updated.
  // More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
  // +optional
  optional string imagePullPolicy = 14;

  // Security options the pod should run with.
  // More info: https://kubernetes.io/docs/concepts/policy/security-context/
  // More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  // +optional
  optional SecurityContext securityContext = 15;

  // Whether this container should allocate a buffer for stdin in the container runtime. If this
  // is not set, reads from stdin in the container will always result in EOF.
  // Default is false.
  // +optional
  optional bool stdin = 16;

  // Whether the container runtime should close the stdin channel after it has been opened by
  // a single attach. When stdin is true the stdin stream will remain open across multiple attach
  // sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
  // first client attaches to stdin, and then remains open and accepts data until the client disconnects,
  // at which time stdin is closed and remains closed until the container is restarted. If this
  // flag is false, a container processes that reads from stdin will never receive an EOF.
  // Default is false
  // +optional
  optional bool stdinOnce = 17;

  // Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
  // Default is false.
  // +optional
  optional bool tty = 18;
}

message ContainerPort {
  // If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
  // named port in a pod must have a unique name. Name for the port that can be
  // referred to by services.
  // +optional
  optional string name = 1;

  // Number of port to expose on the host.
  // If specified, this must be a valid port number, 0 < x < 65536.
  // If HostNetwork is specified, this must match ContainerPort.
  // Most containers do not need this.
  // +optional
  optional int32 hostPort = 2;

  // Number of port to expose on the pod's IP address.
  // This must be a valid port number, 0 < x < 65536.
  optional int32 containerPort = 3;

  // Protocol for port. Must be UDP, TCP, or SCTP.
  // Defaults to "TCP".
  // +optional
  optional string protocol = 4;

  // What host IP to bind the external port to.
  // +optional
  optional string hostIP = 5;
}

message DownwardAPIProjection {
  // Items is a list of DownwardAPIVolume file
  // +optional
  repeated DownwardAPIVolumeFile items = 1;
}

message DownwardAPIVolumeFile {
  // Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
  optional string path = 1;

  // Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
  // +optional
  optional ObjectFieldSelector fieldRef = 2;

  // Selects a resource of the container: only resources limits and requests
  // (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
  // +optional
  optional ResourceFieldSelector resourceFieldRef = 3;

  // Optional: mode bits used to set permissions on this file, must be an octal value
  // between 0000 and 0777 or a decimal value between 0 and 511.
  // YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
  // If not specified, the volume defaultMode will be used.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  // +optional
  optional int32 mode = 4;
}

message DownwardAPIVolumeSource {
  // Items is a list of downward API volume file
  // +optional
  repeated DownwardAPIVolumeFile items = 1;

  // Optional: mode bits to use on created files by default. Must be a
  // Optional: mode bits used to set permissions on created files by default.
  // Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
  // YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
  // Defaults to 0644.
  // Directories within the path are not affected by this setting.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  // +optional
  optional int32 defaultMode = 2;
}

message EmptyDirVolumeSource {
  // What type of storage medium should back this directory.
  // The default is "" which means to use the node's default medium.
  // Must be an empty string (default) or Memory.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
  // +optional
  optional string medium = 1;

  // Total amount of local storage required for this EmptyDir volume.
  // The size limit is also applicable for memory medium.
  // The maximum usage on memory medium EmptyDir would be the minimum value between
  // the SizeLimit specified here and the sum of memory limits of all containers in a pod.
  // The default is nil which means that the limit is undefined.
  // More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
  // +optional
  optional k8s.io.apimachinery.pkg.api.resource.Quantity sizeLimit = 2;
}

message EnvFromSource {
  // An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
  // +optional
  optional string prefix = 1;

  // The ConfigMap to select from
  // +optional
  optional ConfigMapEnvSource configMapRef = 2;

  // The Secret to select from
  // +optional
  optional SecretEnvSource secretRef = 3;
}

message EnvVar {
  // Name of the environment variable. Must be a C_IDENTIFIER.
  optional string name = 1;

  // Variable references $(VAR_NAME) are expanded
  // using the previous defined environment variables in the container and
  // any service environment variables. If a variable cannot be resolved,
  // the reference in the input string will be unchanged. The $(VAR_NAME)
  // syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped
  // references will never be expanded, regardless of whether the variable
  // exists or not.
  // Defaults to "".
  // +optional
  optional string value = 2;

  // Source for the environment variable's value. Cannot be used if value is not empty.
  // +optional
  optional EnvVarSource valueFrom = 3;
}

message EnvVarSource {
  // Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
  // spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
  // +optional
  optional ObjectFieldSelector fieldRef = 1;

  // Selects a resource of the container: only resources limits and requests
  // (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
  // +optional
  optional ResourceFieldSelector resourceFieldRef = 2;

  // Selects a key of a ConfigMap.
  // +optional
  optional ConfigMapKeySelector configMapKeyRef = 3;

  // Selects a key of a secret in the pod's namespace
  // +optional
  optional SecretKeySelector secretKeyRef = 4;
}

message EphemeralVolumeSource {
  // Will be used to create a stand-alone PVC to provision the volume.
  // The pod in which this EphemeralVolumeSource is embedded will be the
  // owner of the PVC, i.e. the PVC will be deleted together with the
  // pod.  The name of the PVC will be `<pod name>-<volume name>` where
  // `<volume name>` is the name from the `PodSpec.Volumes` array
  // entry. Pod validation will reject the pod if the concatenated name
  // is not valid for a PVC (for example, too long).
  //
  // An existing PVC with that name that is not owned by the pod
  // will *not* be used for the pod to avoid using an unrelated
  // volume by mistake. Starting the pod is then blocked until
  // the unrelated PVC is removed. If such a pre-created PVC is
  // meant to be used by the pod, the PVC has to updated with an
  // owner reference to the pod once the pod exists. Normally
  // this should not be necessary, but it may be useful when
  // manually reconstructing a broken cluster.
  //
  // This field is read-only and no changes will be made by Kubernetes
  // to the PVC after it has been created.
  //
  // Required, must not be nil.
  optional PersistentVolumeClaimTemplate volumeClaimTemplate = 1;

  // Specifies a read-only configuration for the volume.
  // Defaults to false (read/write).
  // +optional
  optional bool readOnly = 2;
}

message ExecAction {
  // Command is the command line to execute inside the container, the working directory for the
  // command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
  // not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
  // a shell, you need to explicitly call out to that shell.
  // Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
  // +optional
  repeated string command = 1;
}

message FCVolumeSource {
  // Optional: FC target worldwide names (WWNs)
  // +optional
  repeated string targetWWNs = 1;

  // Optional: FC target lun number
  // +optional
  optional int32 lun = 2;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  // +optional
  optional string fsType = 3;

  // Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // +optional
  optional bool readOnly = 4;

  // Optional: FC volume world wide identifiers (wwids)
  // Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
  // +optional
  repeated string wwids = 5;
}

message FlexVolumeSource {
  // Driver is the name of the driver to use for this volume.
  optional string driver = 1;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
  // +optional
  optional string fsType = 2;

  // Optional: SecretRef is reference to the secret object containing
  // sensitive information to pass to the plugin scripts. This may be
  // empty if no secret object is specified. If the secret object
  // contains more than one secret, all secrets are passed to the plugin
  // scripts.
  // +optional
  optional LocalObjectReference secretRef = 3;

  // Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // +optional
  optional bool readOnly = 4;

  // Optional: Extra command options if any.
  // +optional
  map<string, string> options = 5;
}

message FlockerVolumeSource {
  // Name of the dataset stored as metadata -> name on the dataset for Flocker
  // should be considered as deprecated
  // +optional
  optional string datasetName = 1;

  // UUID of the dataset. This is unique identifier of a Flocker dataset
  // +optional
  optional string datasetUUID = 2;
}

message GCEPersistentDiskVolumeSource {
  // Unique name of the PD resource in GCE. Used to identify the disk in GCE.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  optional string pdName = 1;

  // Filesystem type of the volume that you want to mount.
  // Tip: Ensure that the filesystem type is supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  // +optional
  optional string fsType = 2;

  // The partition in the volume that you want to mount.
  // If omitted, the default is to mount by volume name.
  // Examples: For volume /dev/sda1, you specify the partition as "1".
  // Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  // +optional
  optional int32 partition = 3;

  // ReadOnly here will force the ReadOnly setting in VolumeMounts.
  // Defaults to false.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  // +optional
  optional bool readOnly = 4;
}

message GitRepoVolumeSource {
  // Repository URL
  optional string repository = 1;

  // Commit hash for the specified revision.
  // +optional
  optional string revision = 2;

  // Target directory name.
  // Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
  // git repository.  Otherwise, if specified, the volume will contain the git repository in
  // the subdirectory with the given name.
  // +optional
  optional string directory = 3;
}

message GlusterfsVolumeSource {
  // EndpointsName is the endpoint name that details Glusterfs topology.
  // More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
  optional string endpoints = 1;

  // Path is the Glusterfs volume path.
  // More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
  optional string path = 2;

  // ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions.
  // Defaults to false.
  // More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
  // +optional
  optional bool readOnly = 3;
}

message HTTPGetAction {
  // Path to access on the HTTP server.
  // +optional
  optional string path = 1;

  // Name or number of the port to access on the container.
  // Number must be in the range 1 to 65535.
  // Name must be an IANA_SVC_NAME.
  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 2;

  // Host name to connect to, defaults to the pod IP. You probably want to set
  // "Host" in httpHeaders instead.
  // +optional
  optional string host = 3;

  // Scheme to use for connecting to the host.
  // Defaults to HTTP.
  // +optional
  optional string scheme = 4;

  // Custom headers to set in the request. HTTP allows repeated headers.
  // +optional
  repeated HTTPHeader httpHeaders = 5;
}

message HTTPHeader {
  // The header field name
  optional string name = 1;

  // The header field value
  optional string value = 2;
}

message Handler {
  // One and only one of the following should be specified.
  // Exec specifies the action to take.
  // +optional
  optional ExecAction exec = 1;

  // HTTPGet specifies the http request to perform.
  // +optional
  optional HTTPGetAction httpGet = 2;

  // TCPSocket specifies an action involving a TCP port.
  // TCP hooks not yet supported
  // TODO: implement a realistic TCP lifecycle hook
  // +optional
  optional TCPSocketAction tcpSocket = 3;
}

message HostPathVolumeSource {
  // Path of the directory on the host.
  // If the path is a symlink, it will follow the link to the real path.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
  optional string path = 1;

  // Type for HostPath Volume
  // Defaults to ""
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
  // +optional
  optional string type = 2;
}

message ISCSIVolumeSource {
  // iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
  // is other than default (typically TCP ports 860 and 3260).
  optional string targetPortal = 1;

  // Target iSCSI Qualified Name.
  optional string iqn = 2;

  // iSCSI Target Lun number.
  optional int32 lun = 3;

  // iSCSI Interface Name that uses an iSCSI transport.
  // Defaults to 'default' (tcp).
  // +optional
  optional string iscsiInterface = 4;

  // Filesystem type of the volume that you want to mount.
  // Tip: Ensure that the filesystem type is supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  // +optional
  optional string fsType = 5;

  // ReadOnly here will force the ReadOnly setting in VolumeMounts.
  // Defaults to false.
  // +optional
  optional bool readOnly = 6;

  // iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
  // is other than default (typically TCP ports 860 and 3260).
  // +optional
  repeated string portals = 7;

  // whether support iSCSI Discovery CHAP authentication
  // +optional
  optional bool chapAuthDiscovery = 8;

  // whether support iSCSI Session CHAP authentication
  // +optional
  optional bool chapAuthSession = 11;

  // CHAP Secret for iSCSI target and initiator authentication
  // +optional
  optional LocalObjectReference secretRef = 10;

  // Custom iSCSI Initiator Name.
  // If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
  // <target portal>:<volume name> will be created for the connection.
  // +optional
  optional string initiatorName = 12;
}

message KeyToPath {
  // The key to project.
  optional string key = 1;

  // The relative path of the file to map the key to.
  // May not be an absolute path.
  // May not contain the path element '..'.
  // May not start with the string '..'.
  optional string path = 2;

  // Optional: mode bits used to set permissions on this file.
  // Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
  // YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
  // If not specified, the volume defaultMode will be used.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  // +optional
  optional int32 mode = 3;
}

message Lifecycle {
  // PostStart is called immediately after a container is created. If the handler fails,
  // the container is terminated and restarted according to its restart policy.
  // Other management of the container blocks until the hook completes.
  // More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
  // +optional
  optional Handler postStart = 1;

  // PreStop is called immediately before a container is terminated due to an
  // API request or management event such as liveness/startup probe failure,
  // preemption, resource contention, etc. The handler is not called if the
  // container crashes or exits. The reason for termination is passed to the
  // handler. The Pod's termination grace period countdown begins before the
  // PreStop hooked is executed. Regardless of the outcome of the handler, the
  // container will eventually terminate within the Pod's termination grace
  // period. Other management of the container blocks until the hook completes
  // or until the termination grace period is reached.
  // More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
  // +optional
  optional Handler preStop = 2;
}

message LocalObjectReference {
  // Name of the referent.
  // More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  // TODO: Add other useful fields. apiVersion, kind, uid?
  // +optional
  optional string name = 1;
}

message NFSVolumeSource {
  // Server is the hostname or IP address of the NFS server.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
  optional string server = 1;

  // Path that is exported by the NFS server.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
  optional string path = 2;

  // ReadOnly here will force
  // the NFS export to be mounted with read-only permissions.
  // Defaults to false.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
  // +optional
  optional bool readOnly = 3;
}

message ObjectFieldSelector {
  // Version of the schema the FieldPath is written in terms of, defaults to "v1".
  // +optional
  optional string apiVersion = 1;

  // Path of the field to select in the specified API version.
  optional string fieldPath = 2;
}

message PersistentVolumeClaimSpec {
  // AccessModes contains the desired access modes the volume should have.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
  // +optional
  repeated string accessModes = 1;

  // A label query over volumes to consider for binding.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 4;

  // Resources represents the minimum resources the volume should have.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
  // +optional
  optional ResourceRequirements resources = 2;

  // VolumeName is the binding reference to the PersistentVolume backing this claim.
  // +optional
  optional string volumeName = 3;

  // Name of the StorageClass required by the claim.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
  // +optional
  optional string storageClassName = 5;

  // volumeMode defines what type of volume is required by the claim.
  // Value of Filesystem is implied when not included in claim spec.
  // +optional
  optional string volumeMode = 6;

  // This field can be used to specify either:
  // * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot - Beta)
  // * An existing PVC (PersistentVolumeClaim)
  // * An existing custom resource/object that implements data population (Alpha)
  // In order to use VolumeSnapshot object types, the appropriate feature gate
  // must be enabled (VolumeSnapshotDataSource or AnyVolumeDataSource)
  // If the provisioner or an external controller can support the specified data source,
  // it will create a new volume based on the contents of the specified data source.
  // If the specified data source is not supported, the volume will
  // not be created and the failure will be reported as an event.
  // In the future, we plan to support more data source types and the behavior
  // of the provisioner may change.
  // +optional
  optional TypedLocalObjectReference dataSource = 7;
}

message PersistentVolumeClaimTemplate {
  // May contain labels and annotations that will be copied into the PVC
  // when creating it. No other fields are allowed and will be rejected during
  // validation.
  //
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  // The specification for the PersistentVolumeClaim. The entire content is
  // copied unchanged into the PVC that gets created from this
  // template. The same fields as in a PersistentVolumeClaim
  // are also valid here.
  optional PersistentVolumeClaimSpec spec = 2;
}

message PersistentVolumeClaimVolumeSource {
  // ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  optional string claimName = 1;

  // Will force the ReadOnly setting in VolumeMounts.
  // Default false.
  // +optional
  optional bool readOnly = 2;
}

message PhotonPersistentDiskVolumeSource {
  // ID that identifies Photon Controller persistent disk
  optional string pdID = 1;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  optional string fsType = 2;
}

message PortworxVolumeSource {
  // VolumeID uniquely identifies a Portworx volume
  optional string volumeID = 1;

  // FSType represents the filesystem type to mount
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
  optional string fsType = 2;

  // Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // +optional
  optional bool readOnly = 3;
}

message Probe {
  // The action taken to determine the health of a container
  optional Handler handler = 1;

  // Number of seconds after the container has started before liveness probes are initiated.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  // +optional
  optional int32 initialDelaySeconds = 2;

  // Number of seconds after which the probe times out.
  // Defaults to 1 second. Minimum value is 1.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  // +optional
  optional int32 timeoutSeconds = 3;

  // How often (in seconds) to perform the probe.
  // Default to 10 seconds. Minimum value is 1.
  // +optional
  optional int32 periodSeconds = 4;

  // Minimum consecutive successes for the probe to be considered successful after having failed.
  // Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
  // +optional
  optional int32 successThreshold = 5;

  // Minimum consecutive failures for the probe to be considered failed after having succeeded.
  // Defaults to 3. Minimum value is 1.
  // +optional
  optional int32 failureThreshold = 6;
}

message ProjectedVolumeSource {
  // list of volume projections
  repeated VolumeProjection sources = 1;

  // Mode bits used to set permissions on created files by default.
  // Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
  // YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
  // Directories within the path are not affected by this setting.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  // +optional
  optional int32 defaultMode = 2;
}

message QuobyteVolumeSource {
  // Registry represents a single or multiple Quobyte Registry services
  // specified as a string as host:port pair (multiple entries are separated with commas)
  // which acts as the central registry for volumes
  optional string registry = 1;

  // Volume is a string that references an already created Quobyte volume by name.
  optional string volume = 2;

  // ReadOnly here will force the Quobyte volume to be mounted with read-only permissions.
  // Defaults to false.
  // +optional
  optional bool readOnly = 3;

  // User to map volume access to
  // Defaults to serivceaccount user
  // +optional
  optional string user = 4;

  // Group to map volume access to
  // Default is no group
  // +optional
  optional string group = 5;

  // Tenant owning the given Quobyte volume in the Backend
  // Used with dynamically provisioned Quobyte volumes, value is set by the plugin
  // +optional
  optional string tenant = 6;
}

message RBDVolumeSource {
  // A collection of Ceph monitors.
  // More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  repeated string monitors = 1;

  // The rados image name.
  // More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  optional string image = 2;

  // Filesystem type of the volume that you want to mount.
  // Tip: Ensure that the filesystem type is supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  // +optional
  optional string fsType = 3;

  // The rados pool name.
  // Default is rbd.
  // More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  // +optional
  optional string pool = 4;

  // The rados user name.
  // Default is admin.
  // More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  // +optional
  optional string user = 5;

  // Keyring is the path to key ring for RBDUser.
  // Default is /etc/ceph/keyring.
  // More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  // +optional
  optional string keyring = 6;

  // SecretRef is name of the authentication secret for RBDUser. If provided
  // overrides keyring.
  // Default is nil.
  // More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  // +optional
  optional LocalObjectReference secretRef = 7;

  // ReadOnly here will force the ReadOnly setting in VolumeMounts.
  // Defaults to false.
  // More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  // +optional
  optional bool readOnly = 8;
}

message ResourceFieldSelector {
  // Container name: required for volumes, optional for env vars
  // +optional
  optional string containerName = 1;

  // Required: resource to select
  optional string resource = 2;

  // Specifies the output format of the exposed resources, defaults to "1"
  // +optional
  optional k8s.io.apimachinery.pkg.api.resource.Quantity divisor = 3;
}

message ResourceRequirements {
  // Limits describes the maximum amount of compute resources allowed.
  // More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
  // +optional
  map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> limits = 1;

  // Requests describes the minimum amount of compute resources required.
  // If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
  // otherwise to an implementation-defined value.
  // More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
  // +optional
  map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> requests = 2;
}

message SELinuxOptions {
  // User is a SELinux user label that applies to the container.
  // +optional
  optional string user = 1;

  // Role is a SELinux role label that applies to the container.
  // +optional
  optional string role = 2;

  // Type is a SELinux type label that applies to the container.
  // +optional
  optional string type = 3;

  // Level is SELinux level label that applies to the container.
  // +optional
  optional string level = 4;
}

message ScaleIOVolumeSource {
  // The host address of the ScaleIO API Gateway.
  optional string gateway = 1;

  // The name of the storage system as configured in ScaleIO.
  optional string system = 2;

  // SecretRef references to the secret for ScaleIO user and other
  // sensitive information. If this is not provided, Login operation will fail.
  optional LocalObjectReference secretRef = 3;

  // Flag to enable/disable SSL communication with Gateway, default false
  // +optional
  optional bool sslEnabled = 4;

  // The name of the ScaleIO Protection Domain for the configured storage.
  // +optional
  optional string protectionDomain = 5;

  // The ScaleIO Storage Pool associated with the protection domain.
  // +optional
  optional string storagePool = 6;

  // Indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
  // Default is ThinProvisioned.
  // +optional
  optional string storageMode = 7;

  // The name of a volume already created in the ScaleIO system
  // that is associated with this volume source.
  optional string volumeName = 8;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs".
  // Default is "xfs".
  // +optional
  optional string fsType = 9;

  // Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // +optional
  optional bool readOnly = 10;
}

message SeccompProfile {
  // type indicates which kind of seccomp profile will be applied.
  // Valid options are:
  //
  // Localhost - a profile defined in a file on the node should be used.
  // RuntimeDefault - the container runtime default profile should be used.
  // Unconfined - no profile should be applied.
  // +unionDiscriminator
  optional string type = 1;

  // localhostProfile indicates a profile defined in a file on the node should be used.
  // The profile must be preconfigured on the node to work.
  // Must be a descending path, relative to the kubelet's configured seccomp profile location.
  // Must only be set if type is "Localhost".
  // +optional
  optional string localhostProfile = 2;
}

message SecretEnvSource {
  // The Secret to select from.
  optional LocalObjectReference localObjectReference = 1;

  // Specify whether the Secret must be defined
  // +optional
  optional bool optional = 2;
}

message SecretKeySelector {
  // The name of the secret in the pod's namespace to select from.
  optional LocalObjectReference localObjectReference = 1;

  // The key of the secret to select from.  Must be a valid secret key.
  optional string key = 2;

  // Specify whether the Secret or its key must be defined
  // +optional
  optional bool optional = 3;
}

message SecretProjection {
  optional LocalObjectReference localObjectReference = 1;

  // If unspecified, each key-value pair in the Data field of the referenced
  // Secret will be projected into the volume as a file whose name is the
  // key and content is the value. If specified, the listed keys will be
  // projected into the specified paths, and unlisted keys will not be
  // present. If a key is specified which is not present in the Secret,
  // the volume setup will error unless it is marked optional. Paths must be
  // relative and may not contain the '..' path or start with '..'.
  // +optional
  repeated KeyToPath items = 2;

  // Specify whether the Secret or its key must be defined
  // +optional
  optional bool optional = 4;
}

message SecretVolumeSource {
  // Name of the secret in the pod's namespace to use.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
  // +optional
  optional string secretName = 1;

  // If unspecified, each key-value pair in the Data field of the referenced
  // Secret will be projected into the volume as a file whose name is the
  // key and content is the value. If specified, the listed keys will be
  // projected into the specified paths, and unlisted keys will not be
  // present. If a key is specified which is not present in the Secret,
  // the volume setup will error unless it is marked optional. Paths must be
  // relative and may not contain the '..' path or start with '..'.
  // +optional
  repeated KeyToPath items = 2;

  // Optional: mode bits used to set permissions on created files by default.
  // Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
  // YAML accepts both octal and decimal values, JSON requires decimal values
  // for mode bits. Defaults to 0644.
  // Directories within the path are not affected by this setting.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  // +optional
  optional int32 defaultMode = 3;

  // Specify whether the Secret or its keys must be defined
  // +optional
  optional bool optional = 4;
}

message SecurityContext {
  // The capabilities to add/drop when running containers.
  // Defaults to the default set of capabilities granted by the container runtime.
  // +optional
  optional Capabilities capabilities = 1;

  // Run container in privileged mode.
  // Processes in privileged containers are essentially equivalent to root on the host.
  // Defaults to false.
  // +optional
  optional bool privileged = 2;

  // The SELinux context to be applied to the container.
  // If unspecified, the container runtime will allocate a random SELinux context for each
  // container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
  // PodSecurityContext, the value specified in SecurityContext takes precedence.
  // +optional
  optional SELinuxOptions seLinuxOptions = 3;

  // The Windows specific settings applied to all containers.
  // If unspecified, the options from the PodSecurityContext will be used.
  // If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
  // +optional
  optional WindowsSecurityContextOptions windowsOptions = 10;

  // The UID to run the entrypoint of the container process.
  // Defaults to user specified in image metadata if unspecified.
  // May also be set in PodSecurityContext.  If set in both SecurityContext and
  // PodSecurityContext, the value specified in SecurityContext takes precedence.
  // +optional
  optional int64 runAsUser = 4;

  // The GID to run the entrypoint of the container process.
  // Uses runtime default if unset.
  // May also be set in PodSecurityContext.  If set in both SecurityContext and
  // PodSecurityContext, the value specified in SecurityContext takes precedence.
  // +optional
  optional int64 runAsGroup = 8;

  // Indicates that the container must run as a non-root user.
  // If true, the Kubelet will validate the image at runtime to ensure that it
  // does not run as UID 0 (root) and fail to start the container if it does.
  // If unset or false, no such validation will be performed.
  // May also be set in PodSecurityContext.  If set in both SecurityContext and
  // PodSecurityContext, the value specified in SecurityContext takes precedence.
  // +optional
  optional bool runAsNonRoot = 5;

  // Whether this container has a read-only root filesystem.
  // Default is false.
  // +optional
  optional bool readOnlyRootFilesystem = 6;

  // AllowPrivilegeEscalation controls whether a process can gain more
  // privileges than its parent process. This bool directly controls if
  // the no_new_privs flag will be set on the container process.
  // AllowPrivilegeEscalation is true always when the container is:
  // 1) run as Privileged
  // 2) has CAP_SYS_ADMIN
  // +optional
  optional bool allowPrivilegeEscalation = 7;

  // procMount denotes the type of proc mount to use for the containers.
  // The default is DefaultProcMount which uses the container runtime defaults for
  // readonly paths and masked paths.
  // This requires the ProcMountType feature flag to be enabled.
  // +optional
  optional string procMount = 9;

  // The seccomp options to use by this container. If seccomp options are
  // provided at both the pod & container level, the container options
  // override the pod options.
  // +optional
  optional SeccompProfile seccompProfile = 11;
}

message ServiceAccountTokenProjection {
  // Audience is the intended audience of the token. A recipient of a token
  // must identify itself with an identifier specified in the audience of the
  // token, and otherwise should reject the token. The audience defaults to the
  // identifier of the apiserver.
  // +optional
  optional string audience = 1;

  // ExpirationSeconds is the requested duration of validity of the service
  // account token. As the token approaches expiration, the kubelet volume
  // plugin will proactively rotate the service account token. The kubelet will
  // start trying to rotate the token if the token is older than 80 percent of
  // its time to live or if the token is older than 24 hours.Defaults to 1 hour
  // and must be at least 10 minutes.
  // +optional
  optional int64 expirationSeconds = 2;

  // Path is the path relative to the mount point of the file to project the
  // token into.
  optional string path = 3;
}

message StorageOSVolumeSource {
  // VolumeName is the human-readable name of the StorageOS volume.  Volume
  // names are only unique within a namespace.
  optional string volumeName = 1;

  // VolumeNamespace specifies the scope of the volume within StorageOS.  If no
  // namespace is specified then the Pod's namespace will be used.  This allows the
  // Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
  // Set VolumeName to any name to override the default behaviour.
  // Set to "default" if you are not using namespaces within StorageOS.
  // Namespaces that do not pre-exist within StorageOS will be created.
  // +optional
  optional string volumeNamespace = 2;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // +optional
  optional string fsType = 3;

  // Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // +optional
  optional bool readOnly = 4;

  // SecretRef specifies the secret to use for obtaining the StorageOS API
  // credentials.  If not specified, default values will be attempted.
  // +optional
  optional LocalObjectReference secretRef = 5;
}

message TCPSocketAction {
  // Number or name of the port to access on the container.
  // Number must be in the range 1 to 65535.
  // Name must be an IANA_SVC_NAME.
  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 1;

  // Optional: Host name to connect to, defaults to the pod IP.
  // +optional
  optional string host = 2;
}

message TypedLocalObjectReference {
  // APIGroup is the group for the resource being referenced.
  // If APIGroup is not specified, the specified Kind must be in the core API group.
  // For any other third-party types, APIGroup is required.
  // +optional
  optional string apiGroup = 1;

  // Kind is the type of resource being referenced
  optional string kind = 2;

  // Name is the name of resource being referenced
  optional string name = 3;
}

message Volume {
  // Volume's name.
  // Must be a DNS_LABEL and unique within the pod.
  // More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  optional string name = 1;

  // VolumeSource represents the location and type of the mounted volume.
  // If not specified, the Volume is implied to be an EmptyDir.
  // This implied behavior is deprecated and will be removed in a future version.
  optional VolumeSource volumeSource = 2;
}

message VolumeDevice {
  // name must match the name of a persistentVolumeClaim in the pod
  optional string name = 1;

  // devicePath is the path inside of the container that the device will be mapped to.
  optional string devicePath = 2;
}

message VolumeMount {
  // This must match the Name of a Volume.
  optional string name = 1;

  // Mounted read-only if true, read-write otherwise (false or unspecified).
  // Defaults to false.
  // +optional
  optional bool readOnly = 2;

  // Path within the container at which the volume should be mounted.  Must
  // not contain ':'.
  optional string mountPath = 3;

  // Path within the volume from which the container's volume should be mounted.
  // Defaults to "" (volume's root).
  // +optional
  optional string subPath = 4;

  // mountPropagation determines how mounts are propagated from the host
  // to container and the other way around.
  // When not set, MountPropagationNone is used.
  // This field is beta in 1.10.
  // +optional
  optional string mountPropagation = 5;

  // Expanded path within the volume from which the container's volume should be mounted.
  // Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
  // Defaults to "" (volume's root).
  // SubPathExpr and SubPath are mutually exclusive.
  // +optional
  optional string subPathExpr = 6;
}

message VolumeProjection {
  // information about the secret data to project
  // +optional
  optional SecretProjection secret = 1;

  // information about the downwardAPI data to project
  // +optional
  optional DownwardAPIProjection downwardAPI = 2;

  // information about the configMap data to project
  // +optional
  optional ConfigMapProjection configMap = 3;

  // information about the serviceAccountToken data to project
  // +optional
  optional ServiceAccountTokenProjection serviceAccountToken = 4;
}

message VolumeSource {
  // HostPath represents a pre-existing file or directory on the host
  // machine that is directly exposed to the container. This is generally
  // used for system agents or other privileged things that are allowed
  // to see the host machine. Most containers will NOT need this.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
  // ---
  // TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
  // mount host directories as read/write.
  // +optional
  optional HostPathVolumeSource hostPath = 1;

  // EmptyDir represents a temporary directory that shares a pod's lifetime.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
  // +optional
  optional EmptyDirVolumeSource emptyDir = 2;

  // GCEPersistentDisk represents a GCE Disk resource that is attached to a
  // kubelet's host machine and then exposed to the pod.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  // +optional
  optional GCEPersistentDiskVolumeSource gcePersistentDisk = 3;

  // AWSElasticBlockStore represents an AWS Disk resource that is attached to a
  // kubelet's host machine and then exposed to the pod.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
  // +optional
  optional AWSElasticBlockStoreVolumeSource awsElasticBlockStore = 4;

  // GitRepo represents a git repository at a particular revision.
  // DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
  // EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
  // into the Pod's container.
  // +optional
  optional GitRepoVolumeSource gitRepo = 5;

  // Secret represents a secret that should populate this volume.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
  // +optional
  optional SecretVolumeSource secret = 6;

  // NFS represents an NFS mount on the host that shares a pod's lifetime
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
  // +optional
  optional NFSVolumeSource nfs = 7;

  // ISCSI represents an ISCSI Disk resource that is attached to a
  // kubelet's host machine and then exposed to the pod.
  // More info: https://examples.k8s.io/volumes/iscsi/README.md
  // +optional
  optional ISCSIVolumeSource iscsi = 8;

  // Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
  // More info: https://examples.k8s.io/volumes/glusterfs/README.md
  // +optional
  optional GlusterfsVolumeSource glusterfs = 9;

  // PersistentVolumeClaimVolumeSource represents a reference to a
  // PersistentVolumeClaim in the same namespace.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  // +optional
  optional PersistentVolumeClaimVolumeSource persistentVolumeClaim = 10;

  // RBD represents a Rados Block Device mount on the host that shares a pod's lifetime.
  // More info: https://examples.k8s.io/volumes/rbd/README.md
  // +optional
  optional RBDVolumeSource rbd = 11;

  // FlexVolume represents a generic volume resource that is
  // provisioned/attached using an exec based plugin.
  // +optional
  optional FlexVolumeSource flexVolume = 12;

  // Cinder represents a cinder volume attached and mounted on kubelets host machine.
  // More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  // +optional
  optional CinderVolumeSource cinder = 13;

  // CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
  // +optional
  optional CephFSVolumeSource cephfs = 14;

  // Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
  // +optional
  optional FlockerVolumeSource flocker = 15;

  // DownwardAPI represents downward API about the pod that should populate this volume
  // +optional
  optional DownwardAPIVolumeSource downwardAPI = 16;

  // FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
  // +optional
  optional FCVolumeSource fc = 17;

  // AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
  // +optional
  optional AzureFileVolumeSource azureFile = 18;

  // ConfigMap represents a configMap that should populate this volume
  // +optional
  optional ConfigMapVolumeSource configMap = 19;

  // VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
  // +optional
  optional VsphereVirtualDiskVolumeSource vsphereVolume = 20;

  // Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
  // +optional
  optional QuobyteVolumeSource quobyte = 21;

  // AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
  // +optional
  optional AzureDiskVolumeSource azureDisk = 22;

  // PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
  optional PhotonPersistentDiskVolumeSource photonPersistentDisk = 23;

  // Items for all in one resources secrets, configmaps, and downward API
  optional ProjectedVolumeSource projected = 26;

  // PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
  // +optional
  optional PortworxVolumeSource portworxVolume = 24;

  // ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
  // +optional
  optional ScaleIOVolumeSource scaleIO = 25;

  // StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
  // +optional
  optional StorageOSVolumeSource storageos = 27;

  // CSI (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
  // +optional
  optional CSIVolumeSource csi = 28;

  // Ephemeral represents a volume that is handled by a cluster storage driver (Alpha feature).
  // The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
  // and deleted when the pod is removed.
  //
  // Use this if:
  // a) the volume is only needed while the pod runs,
  // b) features of normal volumes like restoring from snapshot or capacity
  //    tracking are needed,
  // c) the storage driver is specified through a storage class, and
  // d) the storage driver supports dynamic volume provisioning through
  //    a PersistentVolumeClaim (see EphemeralVolumeSource for more
  //    information on the connection between this volume type
  //    and PersistentVolumeClaim).
  //
  // Use PersistentVolumeClaim or one of the vendor-specific
  // APIs for volumes that persist for longer than the lifecycle
  // of an individual pod.
  //
  // Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
  // be used that way - see the documentation of the driver for
  // more information.
  //
  // A pod can use both types of ephemeral volumes and
  // persistent volumes at the same time.
  //
  // +optional
  optional EphemeralVolumeSource ephemeral = 29;
}

message VsphereVirtualDiskVolumeSource {
  // Path that identifies vSphere volume vmdk
  optional string volumePath = 1;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // +optional
  optional string fsType = 2;

  // Storage Policy Based Management (SPBM) profile name.
  // +optional
  optional string storagePolicyName = 3;

  // Storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
  // +optional
  optional string storagePolicyID = 4;
}

message WindowsSecurityContextOptions {
  // GMSACredentialSpecName is the name of the GMSA credential spec to use.
  // +optional
  optional string gmsaCredentialSpecName = 1;

  // GMSACredentialSpec is where the GMSA admission webhook
  // (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
  // GMSA credential spec named by the GMSACredentialSpecName field.
  // +optional
  optional string gmsaCredentialSpec = 2;

  // The UserName in Windows to run the entrypoint of the container process.
  // Defaults to the user specified in image metadata if unspecified.
  // May also be set in PodSecurityContext. If set in both SecurityContext and
  // PodSecurityContext, the value specified in SecurityContext takes precedence.
  // +optional
  optional string runAsUserName = 3;
}

message Bus {
  optional string subject = 1;
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:shortName=eb
message EventBus {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional EventBusSpec spec = 2;

  optional EventBusStatus status = 3;
}

message EventBusList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated EventBus items = 2;
}

message EventBusSpec {
}

message EventBusStatus {
}

message HTTP {
}

message Interface {
  optional bool fifo = 1;

  optional HTTP http = 2;
}

message Kafka {
  optional string url = 1;

  optional string topic = 2;
}

message Node {
  optional Container container = 1;

  // +patchStrategy=merge
  // +patchMergeKey=name
  repeated Volume volumes = 2;

  optional Replicas replicas = 3;

  optional Interface in = 4;

  optional Interface out = 5;

  repeated Source sources = 6;

  repeated Sink sinks = 7;
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:shortName=pl
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`
// +kubebuilder:printcolumn:name="Message",type=string,JSONPath=`.status.message`
message Pipeline {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional PipelineSpec spec = 2;

  optional PipelineStatus status = 3;
}

message PipelineList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated Pipeline items = 2;
}

message PipelineSpec {
  // +patchStrategy=merge
  // +patchMergeKey=name
  repeated Node nodes = 1;
}

message PipelineStatus {
  optional string phase = 1;

  optional string message = 2;

  repeated k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3;
}

message Replicas {
  optional int32 value = 1;
}

message Sink {
  optional string name = 1;

  optional Bus bus = 2;

  optional Kafka kafka = 3;
}

message Source {
  optional string name = 1;

  optional Bus bus = 2;

  optional Kafka kafka = 3;
}

